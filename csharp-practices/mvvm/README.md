# MVVM (Model View View Model)
MVVM is all about separation of concerns

## Separation of concerns
First thing to understand about MVVM is that it is mostly about providing a standard structure for you to apply the principle of separation of concerns. Now that's a pretty lofty phrase that a lot of people throw around without really explaining it, so let's talk briefly about what it really means. To explain separation of concerns, I like to use an analogy of something we all have to do, get dressed to go out in public most days. Now, if you take your laundry as it comes out of the clothes dryer all twisted and tangled, intermingled articles of clothing, and stuff them into any available hole in your drawers or shelves, that can really expedite the process of putting away your clothes at that moment in time when the laundry is done. But then you'll pay an ongoing daily penalty when you're trying to get dressed and out the door because you have to dig around and try to find a matching and complete outfit from the tangled mess of clothing wherever you stuffed it. If, on the other hand, you invest a little time upfront to put the structure in place to organize your clothes, put in some shelves, buy a chest of drawers, and then put a little extra time in each time you're done with the laundry to fold things and put them in their respective shelves or drawers, then the daily activity of getting dressed becomes a breeze. Well, it turns out that developers face a very similar choice with the way we write our code. 

## Separation of concerns in MVVM
For example, you could write code like this, which doesn't look too terrible at first glance, partly because I needed a snippet that would fit on a single slide. But when you look closely at what the code is doing, you have code that's touching and manipulating UI elements interwoven with code that's doing data access interwoven with business logic or interaction logic code. Now take this out of a slide's worth a code and put it into the context of real‑world methods that I'm sure we all have either written or been asked to maintain where you have the same kind of interleaving of concerns, but spread across a method that is hundreds or thousands of lines of code long. This is the code equivalent of taking your tangled mess of clothing and stuffing it in a drawer. The developer who wrote this code has tangled up a bunch of different concerns and put them all in one place. At some point after that, probably on a somewhat ongoing basis, another developer is going to be tasked with adding a feature or fixing a bug that requires digging into this tangle and making changes. That poor soul is going to have to deal with a heap of complexity that goes well beyond whatever specific problem they're trying to address at the moment. And that added complexity is because the developer who originally wrote the code did not take the time to put things in their proper place upfront. So what does MVVM do to address this? Think of it as a set of shelves and drawers that are predefined and well labeled so that each time you go to write code of a certain nature, you have a specific place you should be putting it. There is a shelf where you put your UI element access. That is your View definitions. There is a place for your interaction logic. That is your ViewModels. The data objects you work with go on the Models shelf. Any true business logic should probably be in a separate layer or perhaps behind a service boundary, along with data access being well separated from what the UI code is doing directly. You might also have some shared client‑side logic that's used by multiple Views, and that has its own shelf too. The specific way you set up your shelves and drawers is not really important. It depends on the solution you're working in, the team that you're on, and some personal preference. But having well‑defined places for different kinds of code to go and a good sense of what code goes there is very important and is really what MV.VM is meant to guide you in doing for developing client application code.


## Goal/Benefits of separation of concerns
1. Maintainabilty
    Having that clean separation of different kinds of code should make it easier to go into one or several of those more granular and focused parts and make changes without worrying as much about introducing new bugs or breaking existing features. That means you can remain agile and keep cranking out new releases quickly.
2. Testability
    With MVVM, each piece of code is more granular and, if done right, your external dependencies and UI dependencies are in separate pieces of code from the parts with the core logic that you would really want to unit test. That makes it a lot easier to write unit tests against that core logic, make sure it works right when written, and keeps working even when things change in maintenance. Now, that being said, a lot of teams don't ever get around writing unit tests or just haven't convinced themselves of the benefits of doing so. That's kind of a whole separate topic, and you can find a bunch of good courses on unit testing and why you should be doing it in the Pluralsight library. I'm not going to focus on unit testing in this course as a result, but strongly encourage you to consider unit testing your ViewModel and client service's logic with a decent degree of coverage.
3. Extensibility
    The last benefit is extensibility, and that somewhat overlaps with maintainability. Because of the clean separation boundaries and more granular pieces of code, you have a better chance of making any of those parts more pluggable and being able to replace or add new pieces of code that do similar things into the right places in the architecture. Again, there are some great courses on extensibility in the Pluralsight library as well.

## MVVM Responsibilities
Now let's talk about the responsibilities of each part of the MVVM pattern so that you know what kind of code goes where. MVVM is really a layered architecture for the client side. The presentation layer is composed of the Views. The logic layer are the ViewModels, and the persistence layer is the combination of the model objects and the client services that produce and persist them through either direct data access in a two‑tier application or via service calls in an end‑tier application. And again, the glue that brings together the loosely coupled Views and their corresponding ViewModels and Models is the rich data binding system that WPF provides for us. Let's talk a little bit more about the responsibilities of each of these pieces and what kind of code goes where.

## Model Responsibilities
To dig a little deeper on each part, let's start with the model, because in general it's the simplest to understand. The model is really the client‑side data model that supports the views in the application. It's composed of objects with properties and backing member variables to hold the discrete pieces of data in memory. Some of those properties may reference other model objects, forming the object graph that is the object model as a whole. The model objects might also expose computed properties, properties whose value is computed based on the value of other properties in the model or information from the client execution context. Because you will often be binding directly to model properties, model objects should raise property change notifications, which for WPF data binding means implementing the INotifyPropertyChanged interface and firing the PropertyChanged event in property set blocks. The last responsibility is optional, but often you will embed validation information on the model objects so it can work with the WPF data binding validation features through interfaces such as INotifyDataErrorInfo

## View Responsibilities
The View's responsibility is to define the structure of what the user sees on the screen. That structure can be composed of static and dynamic parts, static being the XAML hierarchy that defines the controls and layout of controls that a view is composed of, and dynamic being any animations or state changes that are defined as part of the View. Now there's an overarching goal when doing MVVM to have no code behind in the View. I put no code behind in quotes here because it's impossible to have zero code behind. You at least need the constructor and the call to initialize component that triggers XAML parsing as the view is being constructed. But the idea is to resist the urge to start dropping event handling code in the code behind encoding up the interaction and data manipulation logic there. There are also other kinds of code that have to go in the code behind. Any code that's required to have a reference to a UI element is inherently View code. Things like animations expressed in code instead of XAML are one example, and many controls have parts of their API that is not conducive to data binding, forcing you to program against them in the code behind. But the key concept here is that when using the MVVM pattern, you should always analyze any code you start to put in the code behind and see if there's any way to make it more declarative in the XAML itself with mechanisms like data binding, commands, or behaviors to dispatch calls into the ViewModel and put that logic there instead.

## ViewModel Responsibilities
Finally, we come to the ViewModel, which is really the focal point of coding up an MVVM application. The primary responsibility of a ViewModel is to provide data to the View so the View can put it on the screen and, if appropriate, let the user interact with and change that data. The other key responsibility of a ViewModel is to encapsulate the interaction logic for a View. That does not mean that all of the logic of the application should go into the ViewModel, which would just create a new place that separation of concerns is being violated. But what should go there is the appropriate sequencing of calls to make the right thing happen based on whatever input just came from the user or whatever change has occurred in the View. The ViewModel should also manage any navigation logic, such as deciding when it is time to navigate to a different View and any cleanup it needs to do if it's being navigated away from. And if there's any logic associated with managing the client application state, the ViewModel can manage those changes. Now, in terms of the data that the ViewModel provides to the View, there's really three kinds of data to consider. The first is exposing model objects directly through ViewModel properties, meaning something like a Customer property on a ViewModel that exposes a reference to a customer model object that could be a whole object graph itself. This is called exposing the model objects. ViewModels can also expose what are called wrapped model objects, meaning properties exposed from the ViewModel that contain data that came from the model, but are not model object references directly. This is done to either simplify the structure of the data for presentation purposes or to transform model object values into something that's more conducive for what the View wants to present. One example would be if a model object contains an enumerated status flag. The ViewModel might transform this into a boolean flag to drive some aspect of the display, such a showing an alert to the customer if it's in an overdue status. Another example would be if the data needed for display was scattered in many places in the object model, but you wanted to present a tabular summary of those bits of data through a collection property for data binding in a grid. These two approaches are called wrapping the model object. The last kind of data that a ViewModel will often manage is client application state, things like is the client application online or offline, or is the user logged in? Flags or properties related to this state can be exposed by the ViewModel to drive the presentation of the View and may often come from .NET APIs about the client execution context or client‑side services that are managing that state.
